name: Build & Deploy Docker -> ECR -> EKS - prod

on:
  push:
    branches: [main]
    paths:
      - ".docker/php/Dockerfile"
      - "k8s/deployment.yaml"
      - "**/Dockerfile"
      - "**/*.php"

jobs:
  deploy:
    runs-on: ubuntu-latest
 
    steps:
    # -----------------------------
    # Checkout code
    # -----------------------------
    - name: Checkout code
      uses: actions/checkout@v4

    # -----------------------------
    # Set AWS environment variables based on branch
    # -----------------------------
    - name: Set AWS environment variables
      run: |
        if [[ "${GITHUB_REF_NAME}" == "dev" ]]; then
          echo "AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID_DEV }}" >> $GITHUB_ENV
          echo "AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY_DEV }}" >> $GITHUB_ENV
          echo "AWS_ACCOUNT_ID=${{ secrets.AWS_ACCOUNT_ID_DEV }}" >> $GITHUB_ENV
          echo "AWS_REGION=${{ secrets.AWS_REGION_DEV }}" >> $GITHUB_ENV
          echo "EKS_CLUSTER_NAME=${{ secrets.EKS_CLUSTER_NAME_DEV }}" >> $GITHUB_ENV
          echo "ECR_REPO_NAME=${{ secrets.ECR_REPO_NAME_DEV }}" >> $GITHUB_ENV
        elif [[ "${GITHUB_REF_NAME}" == "stage" ]]; then
          echo "AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID_STAGE }}" >> $GITHUB_ENV
          echo "AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY_STAGE }}" >> $GITHUB_ENV
          echo "AWS_ACCOUNT_ID=${{ secrets.AWS_ACCOUNT_ID_STAGE }}" >> $GITHUB_ENV
          echo "AWS_REGION=${{ secrets.AWS_REGION_STAGE }}" >> $GITHUB_ENV
          echo "EKS_CLUSTER_NAME=${{ secrets.EKS_CLUSTER_NAME_STAGE }}" >> $GITHUB_ENV
          echo "ECR_REPO_NAME=${{ secrets.ECR_REPO_NAME_STAGE }}" >> $GITHUB_ENV
        else
          echo "AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID_PROD }}" >> $GITHUB_ENV
          echo "AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY_PROD }}" >> $GITHUB_ENV
          echo "AWS_ACCOUNT_ID=${{ secrets.AWS_ACCOUNT_ID_PROD }}" >> $GITHUB_ENV
          echo "AWS_REGION=${{ secrets.AWS_REGION_PROD }}" >> $GITHUB_ENV
          echo "EKS_CLUSTER_NAME=${{ secrets.EKS_CLUSTER_NAME_PROD }}" >> $GITHUB_ENV
          echo "ECR_REPO_NAME=${{ secrets.ECR_REPO_NAME_PROD }}" >> $GITHUB_ENV
        fi

    # -----------------------------
    # Configure AWS
    # -----------------------------
    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ env.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ env.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    # -----------------------------
    # Login to Amazon ECR
    # -----------------------------
    - name: Login to Amazon ECR
      run: |
        aws ecr get-login-password --region $AWS_REGION | \
        docker login --username AWS --password-stdin ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com

    # -----------------------------
    # Build & Push Docker Image
    # -----------------------------
    - name: Build & Push Docker Image
      run: |
        # short SHA tag
        IMAGE_TAG=${GITHUB_SHA::8}
        IMAGE_URI=${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPO_NAME}:${IMAGE_TAG}

        echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV
        echo "IMAGE_URI=$IMAGE_URI" >> $GITHUB_ENV
    
        # Build image from REPO ROOT using your Dockerfile
        docker build \
          -f .docker/php/Dockerfile \
          -t etra-server-v2:${IMAGE_TAG} \
          .

        # Retag to ECR format
        docker tag etra-server-v2:${IMAGE_TAG} $IMAGE_URI
    
        # Push to ECR
        docker push $IMAGE_URI

    # -----------------------------
    # Configure kubectl for EKS
    # -----------------------------
    - name: Update Kubeconfig
      run: aws eks update-kubeconfig --region $AWS_REGION --name $EKS_CLUSTER_NAME

    # -----------------------------
    # Apply Kubernetes manifests
    # -----------------------------
    - name: Delete existing rds restore job
      run: |
        kubectl delete job rds-restore-job --ignore-not-found --wait=true || true
    - name: Apply Kubernetes deployment manifest
      run: |
        kubectl apply -f k8s/deployment.yaml
    - name: Update deployment with new image
      run: |
        kubectl set image deployment/myapp myapp=$IMAGE_URI
        kubectl rollout status deployment/myapp
       
    # -----------------------------
    # Display LoadBalancer URL
    # -----------------------------
    - name: Get LoadBalancer URL
      run: |
        echo "Deployment successful! Getting service details..."
        kubectl get svc myapp-service
        echo "Visit the EXTERNAL-IP shown above to see your application"
